### Addon CLI options
Ember CLI comes with an addon command with the followin usage options:

```
ember addon <addon-name> <options...>
  Creates a new folder and runs ember init in it.
  --dry-run (Default: false)
  --verbose (Default: false)
  --blueprint (Default: addon)
  --skip-npm (Default: false)
  --skip-bower (Default: false)
  --skip-git (Default: false)
```

Note that an addon can NOT be created inside an existing application.
This is to ensure that your addon is developed (and runs) in isolation and doesn't `require` any application files.

### Create addon

To create a basic addon:

`ember addon <addon-name>`

Running this command should generate something like the following:

```
ember addon my-addon
version: 0.0.42
installing
  create .bowerrc
  create .editorconfig
  create tests/dummy/.jshintrc
  create .travis.yml
  create Brocfile.js
  create README.md

  create tests/dummy/app/app.js
  ... more test files

  create bower.json
  create .gitignore
  create package.json  

  ...
  create vendor/.gitkeep
  create addon/.gitkeep
  create app/.gitkeep
  create index.js

Installing packages for tooling via npmb 
Installed browser packages via Bower. 
```

### Structure conventions

`app/` is compiled/merged into the hosting application's namespace. 

`addon/` is compiled/merged into the addon's namespace, creating one addon file.

`tests/` contains the test infrastructure for the addon, including a *dummy app* , your *unit tests* and helpers.

`vendor/` may be used to contain vendor specific files (see details further below)

### Create blueprint

To create a *blueprint* addon:

`ember addon <blueprint-name> --blueprint`

This will create the same addon structure and infrastructure as described above. For more details on blueprints, please see [[generators-and-blueprints]]

Note: A blueprint should have an extra keyword `ember-blueprint` IMO.

### Scenarios
The Ember CLI addons API currently supports the following scenarios:

* Performing operations on the `EmberApp` created in the consuming applications `Brocfile.js`
* Adding preprocessors to the default registry
* Providing a custom application tree to be merged with the consuming application
* Providing custom express (server) middlewares

### Discovery
Ember CLI detects the presence of an addon by inspecting each of your applications dependencies and searching their `package.json` files for the presence of `ember-addon` in the `keywords` section.

### Installation
Any addon can be installed simply via

`npm install --save-dev <package name>`

### Package.json
The generated `package.json` file will look something like this:

```json
{
  "name": "my-addon", // name
  "version": "0.0.0", // versioning
  "directories": {
    "doc": "doc",
    "test": "test"
  },
  "scripts": {
    "start": "ember server",
    "build": "ember build",
    "test": "ember test"
  },
  "repository": "https://github.com/repo-user/my-addon",
  "engines": {
    "node": ">= 0.10.0"
  },
  "keywords": [
    "ember-addon"
    // add more keywords to better categorize the addon 
  ],
  "ember-addon": {
    // addon configuration properties
    "configPath": "tests/dummy/config"
  },
  "author": "", // your name
  "license": "MIT", // license
  "devDependencies": {
    "body-parser": "^1.2.0",
    ... // add specific dev dependencies here!
}
```

You can provide a custom entry point by specifying a `main` property in your `package.json` for the `"ember-addon"` key as illustrated here:

```json
"ember-addon": {
  "main": "lib/ember-addon-main.js", // custom main file
  "configPath": "tests/dummy/config"
}
```

You can also add an entry to define run-time dependencies, ie. node packages that must be included in the hosting app for the addon to function

```json
  "dependencies": {
    ... // add run-time dependencies here!
  }
```

### Entry point
By default the addon will use standard *Node.js* require rules (see _here_ for a breakdown), by default it will look for an `index.js` file in the root. 

The generated deault addon file `index.js` is a simple Javascript Object (POJO) that you can customize and expand as you see fit.

```javascript
// index.js
module.exports = {
  name: 'my-addon'
}
```

###Project
Ember CLI will create a new instance of the class that your addon returns passing it the `Project` instance for the current project (See Customization section below). 

### Testing
The addon created contains a `/tests` folder which contains the necessary infrastructure to run and configure tests for the addon.
The `/tests` folder has the following structure:

- `/dummy`
- `/helpers`
- `/unit`
- `index.html`
- `test_helper.js`

The `/dummy` folder contains the basic layout of a dummy app to be used for to host your addon for testing. 

The `/helpers` folder contains various *qunit* helpers that are provided and those you define yourself in order to keep your tests concise.

The `/helpers` folder should contain your unit tests that test your addon in various usage scenarios. These test may also be full integration tests that test the addon being hosted in the dummy app...

`test_helper.js` is the main helper file that you should reference from any of your unit test files. It imports the `resolver` helper found in `/helpers` used to resolve pages in the `dummy` app.

`index.html` contains the test page that you can load in a browser to display the results of running the unit tests.

Note: This infrastructure very closely resembles testing Engines in Rails, which provide similar "addon" functionality for Rails projects.

### Publish addon
Remove the `"private": true` flag from `package.json` and call `npm publish`. 

Now you can install your addon with: 

`npm install ember-cli-<your-addon-name-here> --save-dev`.

### Customization
The `Project` model has a few functions that might be useful to your addon:

* `require` - Require files or packages from consuming application
* `config` - Returns configuration for provided environment

Some useful `Project` methods:

* `resolve` - Looks up a file from project root

Some useful `EmberApp` methods:

* `import` - import a file into the app

Example: main addon file

```javascript
// lib/ember-addon-main.js

module.exports = {
  name: 'Ember CLI Super Number',

  included: function(app) {
    app.import('vendor/ember-cli-super-number/styles/style.css');
  }
};
```
In the example file, the `included` hook is used. This hook is called by the `EmberApp` constructor and gives access to the app as `app`. 

When the consuming application's `Brocfile.js` is processed by Ember CLI to build/serve etc. the addon's `included` function is called passing the `EmberApp` instance. 

#### Dependency ordering
You can provide a `before` or `after` key (`Array` or `String`) of other addon's package names to be run before or after the addon is loaded.

```javascript
module.exports = {
  // ...
  before: 'plugin-a';
  after: ['plugin-x', 'plugin-z'];
  // ...
}
```

#### Hooks
Here is a list of some useful addon hooks made available.

- `includedCommands` 
- `blueprintsPath` (for blueprint addons)
- `postBuild` 
- `postprocessTree`
- `serverMiddleware`

Usage examples:

```javascript
module.exports = {
  // ...
  // configure path pointing to main blueprints folder
  blueprintsPath: function() {
    return path.join(__dirname, 'blueprints');
  },

  // sets config object
  setConfig: function(){
    var env = this.project.config('development');
    this.config = env.cordova ? env.cordova : {};
  }

  // run after build process
  postBuild: function() {
    return postBuild(this.project, this.config)();
  }

  // run after tree has been processed
  postprocessTree: function(type, tree) {
    var testLoaderTree = /* return a Tree */
    return mergeTrees([tree, testLoaderTree], {
      overwrite: true
    });
  }

  // add server middleware to express app
  serverMiddleware: function(opts) {
    var app = opts.app;
    options = opts.options;

    return if (options.liveReload !== true);
    app.use(require('connect-livereload')({
        port: options.liveReloadPort
    }));
  }  
}
```

#### Customized merge of addon trees
Currently, the following trees can be customized by the addon:

`/app` - merged with `app` tree of application.   
`/styles` - merged with your applications styles (`app/styles/`).
`/vendor` - merged with your applications vendor tree (`/vendor`)
`/addon` - compiled into the addon's namespace (creates one addon file)

Use the addon `/app` folder to add any app files to be picked up by the project hosting the addon.

#### Brocfile customization
If you want to take control of how addon trees are merged into a project
you should use [Broccoli](http://ampersate.com/getting-started-with-broccoli-and-emberjs) and the `Brocfile`:

Brocfile customization example:

```
// Brocfile.js
var mergeTrees = require('broccoli-merge-trees');

var appTree    = mergeTrees(['app', 'app-addon'], { overwrite: true });
var vendorTree = mergeTrees(['vendor', 'vendor-addon']);
```